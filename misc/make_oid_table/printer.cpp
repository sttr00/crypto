#include "printer.h"
#include "make_constant.h"
#include <platform/bits.h>
#include <stdio.h>
#include <memory.h>

using std::string;

static string print_oid_dotted(const oid_info &oid)
{
 string result;
 for (oid_info::const_iterator it = oid.begin(); it != oid.end(); it++)
 {
  if (!result.empty()) result += '.';
  char tmp[64];
  int len = sprintf(tmp, "%u", it->number);
  result.append(tmp, len);
 }
 return result;
}

static bool pack_oid_component(uint8_t *out, size_t out_size, size_t &pos, unsigned val)
{
 size_t bytes = val? bsr32(val)/7 + 1 : 1;
 if (pos + bytes > out_size) return 0;
 int shift = (bytes-1)*7;
 while (shift > 0)
 {
  out[pos++] = (val>>shift) | 0x80;
  shift -= 7;
 }
 out[pos++] = val & 0x7F;
 return true;
}

static size_t pack_oid(uint8_t *out, size_t out_size, const oid_info &oid)
{
 oid_info::const_iterator it = oid.begin();
 if (it == oid.end()) return 0;
 unsigned val = it->number;
 if (val > 2) return 0;
 if (++it == oid.end()) return 0;
 unsigned nval = it->number;
 if (val < 2 && nval > 39) return 0;
 val = val*40 + nval;
 size_t pos = 0;
 for (;;)
 {
  if (!pack_oid_component(out, out_size, pos, val)) return 0;
  if (++it == oid.end()) break;
  val = it->number;
 }
 return pos;
}

static const char *notice = "This file was automatically generated by the 'make_oid_table' program";

bool print_constants(const char *filename, const char *text_filename, const std::vector<oid_info_ex> &v)
{
 FILE *file_const = fopen(filename, "wb");
 if (!file_const) return false;
 FILE *file_text = fopen(text_filename, "wb");
 if (!file_text)
 {
  fclose(file_const);
  return false; 
 }
 string guard(filename);
 for (string::iterator it = guard.begin(); it != guard.end(); it++)
  if (*it == '.' || *it == '-') *it = '_';
 guard.insert(0, "__");
 guard += "__";
 fprintf(file_const,
  "/* %s */\n\n"
  "#ifndef %s\n"
  "#define %s\n\n"
  "#ifdef __cplusplus\n"
  "namespace oid\n"
  "{\n"
  "#endif\n\n"
  " enum\n"
  " {\n", notice, guard.c_str(), guard.c_str());
 fprintf(file_text,
  "// %s\n\n"
  "#define DEF_NAME(n) { n, #n },\n"
  "static const struct { int id; const char *text; } names[] =\n{\n", notice);
 string cname;
 bool first = true;
 for (size_t i = 0; i < v.size(); i++)
 {
  cname = make_constant(v[i].name);
  fprintf(file_const, "  %s", cname.c_str());
  if (first) { fprintf(file_const, " = 1"); first = false; }
  fprintf(file_const, ",\n");
  fprintf(file_text, " DEF_NAME(%s)\n", cname.c_str());
 }
 fprintf(file_const,
  "  MAX_ID = %s\n };\n\n"
  "#ifdef __cplusplus\n"
  "}\n"
  "#endif\n\n"
  "#endif\n", cname.c_str());
 fprintf(file_text, "};\n");
 fclose(file_const);
 fclose(file_text);
 return true;
}

static const char *str_get_func =
"\n"
"const oid::oid_def *oid::get(int id)\n"
"{\n"
" if (id < 1 || id > oid::MAX_ID) return nullptr;\n"
" return defs + id-1;\n"
"}\n";

static string change_extension(const char *filename, const char *new_ext)
{
 string s(filename);
 int pos = s.rfind('.');
 if (pos < 0) s += '.'; else s.erase(pos + 1);
 s += new_ext;
 return s;
}

bool print_definitions(const char *filename, const char *const_filename, const std::vector<oid_info_ex> &v)
{
 FILE *f = fopen(filename, "wb");
 if (!f) return false;
 fprintf(f,
 "// %s\n\n"
 "#include \"%s\"\n"
 "#include \"%s\"\n"
 "#include <stdint.h>\n\n",
  notice, change_extension(filename, "h").c_str(), const_filename);

 uint8_t buf[256];
 char temp1[64], temp2[16];
 int max_len = sprintf(temp1, "%u", unsigned(v.size()));
 memset(temp2, ' ', sizeof(temp2));
 for (size_t i = 0; i < v.size(); i++)
 {
  string cname = make_constant(v[i].name);
  size_t size = pack_oid(buf, sizeof(buf), v[i].oid);
  int len = sprintf(temp1, "%u", unsigned(i + 1));
  temp2[max_len - len] = 0;
  fprintf(f, "static const uint8_t d%s[]%s = {", temp1, temp2);
  for (size_t j = 0; j < size; j++)
  {
   fprintf(f, " 0x%02X", buf[j]);
   if (j != size-1) fprintf(f, ",");
  }
  fprintf(f, " }; // %s\n", cname.c_str());
 }
 fprintf(f, "\nstatic const oid::oid_def defs[] =\n{\n");
 memset(temp2, ' ', sizeof(temp2));
 for (size_t i = 0; i < v.size(); i++)
 {
  int len = sprintf(temp1, "%u", unsigned(i + 1));
  temp2[max_len - len] = 0;
  fprintf(f, " { d%s,%s sizeof(d%s)%s }", temp1, temp2, temp1, temp2);
  if (i != v.size()-1) fprintf(f, ",\n");
 }
 fprintf(f, "\n};\n");
 fprintf(f, str_get_func); 
 fclose(f);
 return true;
}

struct oid_search_node
{
 unsigned index;
 string const_name;
 string text_info;
 oid_search_node *next[256];
 
 oid_search_node()
 {
  index = 0;
  memset(next, 0, sizeof(next));
 }
};

static void print_search_node(FILE *f, const oid_search_node &node)
{
 char tmp[256];
 int ch_byte[256];
 int ch_dest[256];
 int ch_count = 0;
 for (int i = 0; i < 256; i++)
  if (node.next[i])
  {
   ch_byte[ch_count] = i;
   ch_dest[ch_count] = node.next[i]->index;
   ch_count++;
  }
 string ch_desc;
 static const int MAX_INDENT = 6;
 char indent[MAX_INDENT + 1];
 memset(indent, ' ', sizeof(indent));
 int indent_pos;
 if (ch_count)
 {
  int len = sprintf(tmp, "sl%u", node.index);
  ch_desc.assign(tmp, len);
  indent_pos = MAX_INDENT - (static_cast<int>(ch_desc.length()) + 2);
  if (indent_pos < 0) indent_pos = 0;
  indent[indent_pos] = 0;
  fprintf(f, "static const oid_search_link %s[]%s = {", ch_desc.c_str(), indent);
  indent[indent_pos] = ' ';
  for (int i = 0; i < ch_count; i++)
  {
   if (i) fprintf(f, ",");
   fprintf(f, " { %u, &n%u }", ch_byte[i], ch_dest[i]);
  }
  fprintf(f, " };\n");
 }
 if (ch_desc.empty()) ch_desc = "NULL";
 int len = sprintf(tmp, "n%u", node.index);
 indent_pos = MAX_INDENT - len;
 if (indent_pos < 0) indent_pos = 0;
 indent[indent_pos] = 0;
 fprintf(f, "static const oid_search_node %s%s = { %s, %d, %s };",
  tmp, indent, node.const_name.empty()? "0" : node.const_name.c_str(), ch_count, ch_desc.c_str()); 
 if (!node.text_info.empty()) fprintf(f, " // %s", node.text_info.c_str());
 fputc('\n', f);
}

static const char *str_search_defs =
"struct oid_search_node\n"
"{\n"
" int id;\n"
" int count;\n"
" const struct oid_search_link *links;\n"
"};\n"
"\n"
"struct oid_search_link\n"
"{\n"
" unsigned byte;\n"
" const oid_search_node *next;\n"
"};\n\n";

bool print_search_tree(const char *filename, const char *const_filename,
                       const std::vector<oid_info_ex> &v)
{
 FILE *f = fopen(filename, "wb");
 if (!f) return false;
 fprintf(f,
 "// %s\n\n"
 "#include \"%s\"\n"
 "#include \"%s\"\n\n"
 "using namespace oid;\n\n%s",
  notice, change_extension(filename, "h").c_str(),
  const_filename, str_search_defs);

 oid_search_node *root = new oid_search_node;
 unsigned node_index = 0;
 for (size_t i = 0; i < v.size(); i++)
 {
  uint8_t buf[256];
  size_t size = pack_oid(buf, sizeof(buf), v[i].oid);
  oid_search_node *current = root;
  for (size_t j = 0; j < size; j++)
  {
   oid_search_node *next = current->next[buf[j]];
   if (!next)
   {
    oid_search_node *new_node = new oid_search_node;
    if (j == size-1)
    {
     new_node->const_name = make_constant(v[i].name);
     new_node->text_info = print_oid_dotted(v[i].oid);
    }
    new_node->index = ++node_index;
    current->next[buf[j]] = new_node;
    current = new_node;
   } else current = next;
  }
 }

 struct dfs_stack_entry
 {
  oid_search_node *node;
  int pos;
 };
 std::vector<dfs_stack_entry> stack;
 dfs_stack_entry entry = { root, 0 };
 stack.push_back(entry);
 while (!stack.empty())
 {
  dfs_stack_entry &t = stack.back();
  if (t.pos >= 256)
  {
   print_search_node(f, *t.node);
   stack.pop_back();
  } else
  {
   oid_search_node *next = t.node->next[t.pos++];
   if (next)
   {
    entry.node = next;
    entry.pos = 0;
    stack.push_back(entry);
   }
  }
 }

 entry.node = root;
 entry.pos = 0;
 stack.push_back(entry);
 while (!stack.empty())
 {
  dfs_stack_entry &t = stack.back();
  if (t.pos >= 256)
  {
   delete t.node;
   stack.pop_back();
  } else
  {
   oid_search_node *next = t.node->next[t.pos++];
   if (next)
   {
    entry.node = next;
    entry.pos = 0;
    stack.push_back(entry);
   }
  }
 }
 
 fprintf(f, "\n#include \"%s\"\n", change_extension(filename, "inc").c_str());
 fclose(f);
 return true;
}
